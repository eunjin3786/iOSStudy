# 재사용 큐 (Reuse Queue)

테이블 뷰를 구성하기 위해 준비된 데이터 소스가 백 개라면 일반적으로 백 개의 테이블뷰 cell을 만든다고 생각하기 쉽다.  

하지만 iOS 시스템은 백 개의 테이블뷰 셀 객체를 모두 한 번에 만들어내지 않는다. iOS 기기의 메모리와 배터리를 절약하기 위해서이다. 데이터 소스 수 만큼 테이블 뷰 셀을 만들어내는 대신 당장 현재의 화면에 표시되어야하는 만큼만 셀을 생성해내고 그때그때 스크롤이 올때 필요에 따라 셀을 추가한다.  

이 과정에서 매번 새로운 셀을 생성하면 너무 메모리의 부담이 크다. 재사용 큐(셀 객체를 저장하는 공간)을 만들어두고 여기에 샐 객체를 저장해두었다가 필요할때 꺼내어 사용한다. 

재활용가능한 셀이 있다면 굳이 새로 생성하지않고 재활용한다.   

재사용 큐에 저장된 셀 자체는 재사용하지만, 셀의 콘텐츠는 `tableView(_:cellForRowAt:)` 메소드를 통해 매번 새롭게 구성된다. 




# 재사용 메커니즘 (Reuse Mechanism)

1. 테이블 뷰가 화면에 나타낼 셀 객체를 자신의 데이터 소스에게 요청한다

2. 데이터 소스는 테이블 뷰의 재사용 큐(Reuse Queue) 에서 사용가능한 셀이 있는지 확인하여 만일 있으면  그 중 하나를 꺼내 전달하고, 없으면 새로운 셀을 생성한다. 

3. `tableView(_:cellForRowAt:)` 메소드가 셀의 콘텐츠를 구성해서 return cell하면 테이블 뷰는 이 셀을 받아 화면에 표시한다 

4. 사용자가 테이블 뷰를 스크롤함에 따라 화면을 벗어난 셀은 테이블 뷰에서 제거되지만 완전히 삭제되는 것은 아니다. 재사용 큐에 추가된다 

5. 사용자의 스크롤에 따라  1~4과정을 반복한다



![img_0855](https://user-images.githubusercontent.com/9502063/51123593-be966d80-185f-11e9-8cfd-17147582033e.png)

```
enqueue -> | 3 | 2 | 1 | -> dequeue
```



### 반성

- 일단 데이터를 받아와서 해당 모델에 데이터가 들어간 후 section 개수로 쳐줘야하는데 그냥 section개수로 return 1을 해줬음. 그래서 처음 tableview가 로드 될때 데이터가 없는 데 1로 들어가버림!! 

- 그리고 이 상태에서  guard let으로 한줄로 코딩해주고 싶어서 tableviewcell 캐스팅이 가능하고 뿌려줄 model이 nil이 아닐때 UITableViewCell() 을 리턴해주었음. 그래서 reuse queue는 처음 테이블뷰가 로드될때 UITableViewCell()을 가지게 되고 이 cell을 재사용해주게 됨. 그래서 원하는 cell이 안나오고 테이블뷰 다시 리로드해도 이 cell이 나오게 됨 

  

  엉엉엉엉 바보같다. 레이아웃 문제인줄 알고 하루종일 고생했는데 이 부분을 생각하지 못했다!! 😥



### Reference 

- 친절한 재은씨의 스위프트 프로그래밍 